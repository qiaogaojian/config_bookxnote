{"EpubVersion":1,"filepath":"","floatingtheme":[],"folded":false,"markups":[{"date":"2021-11-09 14:02:39","folded":true,"id":4,"linecolor":"ff59c6ff","markups":[{"annotations":[{"content":"5594501e59c3d8bf698c7211191f38e0.png","style":1}],"date":"2021-11-09 13:58:26","docid":0,"fillcolor":"fffeeb73","folded":true,"id":2,"originaltext":"一个Socket包含了进行网络通信必需的五种信息：\n连接使用的协议、 \n本地主机的IP地址、 \n本地的协议端口、 \n远程主机的IP地址、\n远程协议端口\n","page":20,"textblocks":[{"first":[214.739990234375,334.32598876953125,10.143142700195312,13.55999755859375],"last":[306.58697509765625,367.0539855957031,9.061492919921875,12.5],"length":72,"rects":[[214.739990234375,334.32598876953125,102.37252807617188,13.55999755859375],[24.850000381469727,349.4339904785156,294.2460079193115,13.5],[23.3700008392334,367.0539855957031,292.2784671783447,12.5]],"start":141,"text":"一个Socket包含了进\n行网络通信必需的五种信息：连接使用的协议、 本地主机的IP\n地址、 本地的协议端口、 远程主机的IP地址和远程协议端口"}],"title":"Socket包含的信息","type":5},{"date":"2021-11-09 14:07:46","docid":0,"fillcolor":"fffeeb73","id":5,"originaltext":"网络上的计算机都是通过IP地址识别的， 应用程序通过通信端口彼此通信。\n“端口”是英文port的意译，是设备与外界通信交流的出口。 每台计算机可以分配0到65535共65 536个端口。 通俗地讲，每个Socket连接都是从一台计算机的一个端口连接到另外一台计符机的某个端口。","page":20,"textblocks":[{"first":[46.209999084472656,486.3639831542969,10.269001007080078,12.5],"last":[410.62664794921875,486.3639831542969,4.410003662109375,12.5],"length":35,"rects":[[46.209999084472656,486.3639831542969,368.82665252685547,12.5]],"start":438,"text":"网络上的计算机都是通过IP地址识别的， 应用程序通过通信端口彼此通信。"}],"title":"IP和端口","type":5},{"date":"2021-11-09 14:09:40","docid":0,"fillcolor":"fffeeb73","id":6,"originaltext":"每台计算机可以分配0到65535共65 536个端口。","page":21,"textblocks":[{"first":[343.3499755859375,343.333984375,8.227996826171875,12.5],"last":[140.83819580078125,360.7340087890625,4.938995361328125,13.5],"length":28,"rects":[[343.3499755859375,343.333984375,117.79000854492188,12.5],[31.769989013671875,360.7340087890625,114.0072021484375,13.5]],"start":438,"text":"每台计算机可以分配0到\n65535共65 536个端口。"}],"title":"一台计算机有多少端口","type":5,"width":350},{"content":"就像打电话分为“呼叫方”和“接听方”一样， Socket通信分也为“连接方”和“监听方”:连接方使用不同的端口连接， 监听方只使用一个端口监听。 图 1-10 中 Socket E 在 Socket A连接后产生， 代表着 Socket A 和服务端的连接， Socket F 在 Socket B 连接后产生， 代表养Socket B 和服务端的连接。","date":"2021-11-09 14:13:13","docid":0,"id":7,"imgfile":"e3ae51538cda7c42dea8d9027bf83b3b.png","linecolor":"ffa0ec6f","linewidth":2,"page":22,"rect":[53.047498419061355,297.7893661251853,430.4081121728387,636.5699810287363],"title":"Socket连接示意图","type":2},{"content":"l) 开启一个连接之前， 需要创建一个 Socket 对象（使用 API Socket)，然后绑定本地使用的端口（使用 API Bind) 。 对服务端而言， 绑定的步骤相当于给手机插上 SIM 卡，确定了“手机号”。 对客户端而言， 连接时（使用 API Connect) 会由系统分配端口，可以省去绑定步骤。\n2) 服务端开启监听（使用 API Listen)， 等待客户端接入。 相当于电话开机， 等待别人呼叫。\n3) 客户端连接服务器（使用 APT Connect)， 相当于手机拨号。\n4) 服务器接受连接（使用 API Accept)， 相当千接听电话并说出“喂＂。通过这4个步骤， 成功建立连接， 可以收发数据。\n5) 客户端和服务端通过 Send 和 Receive 等 API 收发数据， 操作系统会自动完成数据的确认、 重传等步骤， 确保传输的数据准确无误。\n6) 某一方关闭连接（使用 API Close)， 操作系统会执行“四次挥手”的步骤， 关闭双方连接， 相当千挂断电话。\n","date":"2021-11-09 14:19:39","docid":0,"id":8,"imgfile":"d77c8b5426fa25edfbda777aa33f9b28.png","linecolor":"ffa0ec6f","linewidth":2,"page":24,"rect":[112.72593414050537,46.416561116678686,375.552176307673,287.5415539305939],"title":"Socket通信流程","type":2},{"date":"2021-11-09 14:23:47","docid":0,"fillcolor":"fffeeb73","id":9,"originaltext":"<body style=\" font-family:'Microsoft YaHei UI'; font-size:9pt; font-weight:400; font-style:normal;\">\n<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\">从概念上讲， TCP 是一种<span style=\" font-weight:600;\">面向连接的</span>、 <span style=\" font-weight:600;\">可靠的</span>、 基于字节流的传输层通信协议，与TCP 相对应的 UDP 协议是<span style=\" font-weight:600;\">无连接的</span>、 <span style=\" font-weight:600;\">不可靠的</span>、 <span style=\" font-weight:600;\">但传输效率较高</span>的协议。</p></body>","page":24,"textblocks":[{"first":[48.679908752441406,477.31396484375,10.529998779296875,12.5],"last":[378.8839111328125,494.03399658203125,4.709991455078125,12.5],"length":81,"rects":[[48.679908752441406,477.31396484375,408.7100143432617,12.5],[27.12994384765625,494.03399658203125,356.4639587402344,12.5]],"start":370,"text":"从概念上讲， TCP 是一种面向连接的、 可靠的、 基于字节流的传输层通信协议，与\nTCP 相对应的 UDP 协议是无连接的、 不可靠的、 但传输效率较高的协议。"}],"title":"TCP UDP简介","type":5},{"date":"2021-11-09 14:48:33","docid":0,"fillcolor":"fffeeb73","id":10,"originaltext":"<body style=\" font-family:'Microsoft YaHei UI'; font-size:9pt; font-weight:400; font-style:normal;\">\n<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\">Socket (AddressFamily.lnterNetwork, SocketType.Stream, Protocol Type. Tep)这一行JIJ千创建一个Socket对象，它的三个参数分别代表<span style=\" font-weight:600;\">地址族</span>、<span style=\" font-weight:600;\">套接字类型</span>和<span style=\" font-weight:600;\">协议</span>。</p>\n<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\">地址族指明使用IPv4还是1Pv6</p>\n<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\">SocketType是套接字类型，类型如表1-5所示，游戏开发中最常用的是字节流套接字，即Stream。</p>\n<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\">ProtocolType指明协议， 本例使用的是TCP协议， 部分协议类型如表1-6所示。若要使用传输速度更快的UDP协议而不是较为可靠的TCP（回顾1.2.5节的内容），需要更改协议类型”Socket (AddressFamily.lnterNetwork, SocketType.Dgram, Protocol­Type. Udp)&quot;。</p></body>","page":27,"textblocks":[{"first":[55.830013275146484,272.10406494140625,6.263999938964844,15.5],"last":[395.3199462890625,289.71405029296875,4.058990478515625,13.5],"length":118,"rects":[[55.830013275146484,272.10406494140625,408.916934967041,15.5],[35.75,289.71405029296875,363.6289367675781,13.5]],"start":254,"text":"Socket (AddressFamily.lnterNetwork, SocketType.Stream, Protocol Type. Tep)这一行JIJ\n千创建一个Socket对象，它的三个参数分别代表地址族、套接字类型和协议。"}],"title":"Socket对象构造函数","type":5},{"annotations":[{"content":"71bdff30a49c657bc60be3c5f1c21ee3.png","style":1}],"date":"2021-11-09 14:49:39","docid":0,"fillcolor":"fffeeb73","id":11,"originaltext":"地址族指明使用IPv4还是1Pv6, 其含义如表1-4所示，本例中使用的是1Pv4,即InterNetwork。\n","page":27,"textblocks":[{"first":[65.55633544921875,307.8740539550781,13.464004516601562,13.5],"last":[283.74993896484375,324.60406494140625,4.51800537109375,14.600006103515625],"length":57,"rects":[[65.55633544921875,307.8740539550781,236.99740600585938,13.5],[65.39994812011719,324.60406494140625,222.8679962158203,14.600006103515625]],"start":374,"text":"地址族指明使用IPv4还是1Pv6, 其含义如表1-4\n所示，本例中使用的是1Pv4,即InterNetwork。"}],"title":"地址族的含义","type":5},{"date":"2021-11-09 14:54:15","docid":0,"fillcolor":"fffeeb73","id":12,"originaltext":"<body style=\" font-family:'Microsoft YaHei UI'; font-size:9pt; font-weight:400; font-style:normal;\">\n<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\">客户端通过socket.Connect（远程IP地址， 远程端口）连接服务端。Connect 是一个<span style=\" font-weight:600;\">阻塞方法</span>， 程序会卡住直到服务端回应（接收、拒绝或超时）。</p></body>","page":28,"textblocks":[{"first":[46.400001525878906,290.6839599609375,10.206001281738281,16.5],"last":[296.90203857421875,308.77398681640625,6.29998779296875,13.5],"length":80,"rects":[[46.400001525878906,290.6839599609375,409.1646041870117,16.5],[24.540000915527344,308.77398681640625,278.66202545166016,13.5]],"start":425,"text":"客户端通过socket.Connect（远程IP地址， 远程端口）连接服务端。Connect 是一个阻\n塞方法， 程序会卡住直到服务端回应（接收、拒绝或超时）。"}],"title":"Socket.Connect方法","type":5},{"date":"2021-11-09 14:56:53","docid":0,"fillcolor":"fffeeb73","id":13,"originaltext":"<body style=\" font-family:'Microsoft YaHei UI'; font-size:9pt; font-weight:400; font-style:normal;\">\n<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\">客户端通过socket.Send发送数据， 这也是一个<span style=\" font-weight:600;\">阻塞方法</span>。 该方法接受一个byte[］类型的参数指明要发送的内容。<span style=\" font-weight:600;\">Send的返回值指明发送数据的长度 </span>（例子中没有使用）。 程序用System.Text.<span style=\" font-weight:600;\">Encoding.Default.GetBytes（字符串）</span>把字符串转换成byte[]数组，然后发送给服务端。</p></body>","page":28,"textblocks":[{"first":[46.650001525878906,343.2140197753906,10.206001281738281,15.04998779296875],"last":[59.28450012207031,394.2939758300781,8.158500671386719,12.5],"length":162,"rects":[[46.650001525878906,343.2140197753906,407.02388763427734,15.04998779296875],[22.469999313354492,360.1239929199219,435.9794635772705,12.5],[25.219999313354492,372.3583984375,432.5484027862549,19.869476318359375],[22.709999084472656,394.2939758300781,44.733001708984375,12.5]],"start":518,"text":"客户端通过socket.Send发送数据， 这也是一个阻塞方法。 该方法接受一个byte[］类型\n的参数指明要发送的内容。Send的返回值指明发送数据的长度 （例子中没有使用）。 程序用\nSystem.Text.Encoding.Default.GetBytes（字符串）把字符串转换成byte[]数组，然后发送给\n服务端。"}],"title":"Socket.Send方法","type":5},{"date":"2021-11-09 14:57:10","docid":0,"fillcolor":"fffeeb73","id":14,"originaltext":"<body style=\" font-family:'Microsoft YaHei UI'; font-size:9pt; font-weight:400; font-style:normal;\">\n<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\">客户端通过socket.Receive接收服务端数据。Receive也是<span style=\" font-weight:600;\">阻塞方法</span>，没有收到服务端数据时，程序将卡在Receive不会往下执行。Receive带有一个byte[］类型的参数，它存储接收到的数据 。<span style=\" font-weight:600;\">Receive的返回值指明接收到 数据的长度</span>。 之后使用<span style=\" font-weight:600;\">System.Text.Encoding.Default.GetString(readBuff,O,count)</span>将byte[］ 数组转换成字符串显示在屏幕上 。</p></body>","page":28,"textblocks":[{"first":[46.90999984741211,428.3240051269531,10.206001281738281,13.5],"last":[386.9200134277344,474.4504089355469,8.15850830078125,19.629486083984375],"length":216,"rects":[[46.90999984741211,428.3240051269531,410.99170303344727,13.5],[26.860000610351562,444.4339904785156,428.2294158935547,14.5],[22.649999618530273,461.0160217285156,433.26140785217285,15.65997314453125],[24.809999465942383,474.4504089355469,370.26852226257324,19.629486083984375]],"start":696,"text":"客户端通过socket.Receive接收服务端数据。Receive也是阻塞方法，没有收到服务端\n数据时，程序将卡在Receive不会往下执行。Receive带有一个byte[］类型的参数，它存储\n接收到的数据 。Receive的返回值指明接收到 数据的长度。 之后使用System.Text.Encoding.\nDefault.GetString(readBuff,O,count)将byte[］ 数组转换成字符串显示在屏幕上 。"}],"title":"Socket.Receive方法","type":5},{"date":"2021-11-09 16:03:19","docid":0,"fillcolor":"fffeeb73","id":15,"originaltext":"如果将服务端放到连接路由器的某台计算机上，因为它只有局域网IP,所以只有局域网内的计算机可以连接上。 如果拥有路由器的控制权，可以使用一种叫“端口映射”的技术， 即设置路由器， 将路由器IP地址的一个端口映射到内网中的一台计算机， 提供相应的服务。","page":35,"textblocks":[{"first":[239.92530822753906,294.8799743652344,10.20599365234375,14.480010986328125],"last":[223.30340576171875,345.1939697265625,4.5989990234375,12.5],"length":127,"rects":[[239.92530822753906,294.8799743652344,226.34474182128906,14.480010986328125],[37.779998779296875,311.14398193359375,428.47003173828125,12.5],[36.66999816894531,327.38397216796875,430.3467254638672,12.5],[36.869998931884766,345.1939697265625,191.03240585327148,12.5]],"start":325,"text":"如果将服务端放到连接路由器的某台计算机上，\n因为它只有局域网IP,所以只有局域网内的计算机可以连接上。 如果拥有路由器的控制权，\n可以使用一种叫“端口映射”的技术， 即设置路由器， 将路由器IP地址的一个端口映射到\n内网中的一台计算机， 提供相应的服务。"}],"title":"内网服务器怎么提供外网服务","type":5}],"page":-1,"title":"第1章 网络游戏的开端Echo","type":7,"width":184},{"date":"2021-11-09 16:06:38","id":16,"linecolor":"ff59c6ff","page":-1,"title":"第2章 分身有术: 异步和多路复用","type":7,"width":203}],"maxid":16,"title":"Unity网络游戏实战 第二版 罗培羽","unimportant":[]}